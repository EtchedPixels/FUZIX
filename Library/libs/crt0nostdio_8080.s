!
!	Segment order matters
!
.sect .text
.sect .rom
.sect .data
.sect .bss

.sect .text

.define __text		! We will need this for the syscall changes
			! to get at the stubs
__text:
		.data2 0x80A8	! Fuzix executable
		.data1 1	! 8080 series
		.data1 0	! No additional features
		.data1 1	! Base 0x100
		.data1 0	! No hints

		! These three are set properly by binman
		.data2 0			! code
		.data2 0			! data
		.data2 0			! bss size

		.data1 18			! Run 18 bytes in
		.data1 0			! No size hint
		.data1 0			! No stack hint
		.data1 0			! No ZP on 8080

		.data2 __sighandler		! signal handler vector

start2:
!
!	Install the RST handlers. What we really want to do is have
!	standard RST handlers in common that use variables in low space
!	but for now just carry it
!
!	The kernel uses the handlers in the kernel bank so this is ok
!
		call .rst_init		! before we hit C code
		lxi h,4
		dad sp
		shld _environ
		pop d			! argc
		pop h			! argv
		push h
		shld ___argv		! needed for stuff like err()
		push d
		call _main		! go
		push d
		call _exit

!
!	Trap glue. Generated by the runtime. We should translate them
!	to signal handlers. If we ever turn on runtime checking we will
!	need a few more
!
.define eoddz
.define ecase
.define eidivz
.define eunimpl
!
!	FIXME: what to do
!
eunimpl:			! unimplemented ??
eoddz:				! invalid argument size
ecase:				! case error
		lxi h,255
		call _exit

eidivz:				! divide by 0
		push h
		lxi h,8		! SIGFPE
		push h
		call _getpid	! us
		push h
		call _kill
		pop h
		pop h
		pop h
		ret

!
!	Signal handling glue. Called to indirect signals from the kernel
!	through code that saves the non-rentrant OS glue. Our stack
!	on entry has the return frame and we are passed C=signal number
!
__sighandler:
		! We need to save DE and C so it's easiest to do the long
		! winded thing, especially as signhandler might be
		! re-entered
		lhld .retadr
		push h
		lhld .retadr1
		push h
		lhld .bcreg
		push h
		lhld .areg
		push h
		lhld .tmp1
		push h
		lhld .fra
		push h
		lhld .fra+2
		push h
		lhld .fra+4
		push h
		lhld .fra+6
		push h
		lhld block1
		push h
		lhld block1+2
		push h
		lhld block2
		push h
		lhld block2+2
		push h
		lhld block3
		push h
		lhld block3+2
		push h
		mvi b,0
		push b			! signal number
		xchg
		call .pchl
		pop b
		!
		!	We stacked in order so we can unwind properly
		!
		lxi h,block3+3
		mvi b,15
unstack:
		pop d
		mov m,d
		dcx h
		mov m,e
		dcx h
		dcr b
		jnz unstack
		ret			! to the previous frame via the
					! kernel helpers

.sect .data

__data:			! so we can find it

! Start with the ugly ack non re-entrant stuff we will eventually need to
! stack for signal handling (gak)
!

.define __non_re
.define __end_non_re

__non_re:
.define .trapproc, .retadr, .retadr1
.define .bcreg, .areg
.define .tmp1, .fra, block1, block2, block3

.trapproc: .space 2
.retadr: .space 2        ! used to save return address
.retadr1: .space 2       ! reserve
.bcreg: .space 2
.areg: .space 2		! one spare
.tmp1: .space 2
.fra: .space 8           ! 8 bytes function return area
block1: .space 4        ! used by 32 bits divide and
block2: .space 4        ! multiply routines
block3: .space 4        ! must be contiguous (.comm doesn't guarantee this)

__end_non_re:

.define _environ
_environ:	.data2 0

.sect .bss

__bss:

